"""Functions to fetch git SHA information from singularity containers."""

import re


def get_shas_from_singularity(dev_versions_today, dev_versions_yesterday):
    """Get git SHAs from ``setuptool-scm`` version strings.

    SCM version strings are generated by the command ``esmvaltool version`` and
    imported as environment variables. Strings include both packages split by
    a newline. E.g. ``ESMValCore: 2.13.0.dev54+g82d795ec\nESMValTool:
    2.13.0.dev66+g53c339c5c\n`` where the short SHA-1s are ``82d795ec`` and
    ``53c339c5c``.

    Parameters
    ----------
    dev_version_today : str | None
        SCM version string for today's package versions.
    dev_version_yesterday : str | None
        SCM version string for yesterday's package versions.

    Notes
    -----
    The regex used expects short SHAs between "+g" and a new line in the SCM
    version strings. A branch with uncommited changes would break this pattern
    but that should not be possible from a container.

    More on setuptools scm's versioning scheme here under "Default verisioning
    scheme:
    https://setuptools-scm.readthedocs.io/en/latest/usage/

    More on short SHA-1s in general here:
    https://git-scm.com/book/en/v2/Git-Tools-Revision-Selection

    Returns
    -------
    all_shas: dict[str, dict[str, str]]
        A dictionary where keys are the package and the values are a dict of
        days and short SHAs. E.g.
        ``{"ESMValCore": {"today": "abcd123", "yesterday": "efgh456"}...}``.
    """
    all_shas = {"ESMValCore": {}, "ESMValTool": {}}
    pkg_versions_by_day = [("today", dev_versions_today)]

    if dev_versions_yesterday:
        pkg_versions_by_day.append(("yesterday", dev_versions_yesterday))
    else:
        print("Only today's SHAs are available.")

    for day, package_versions in pkg_versions_by_day:
        shas = re.findall(r"\+g(.*?)$", package_versions, re.MULTILINE)
        if len(shas) == 2:
            all_shas["ESMValCore"][day] = shas[0]
            all_shas["ESMValTool"][day] = shas[1]
        else:
            print(f"Unexpected SHA format for {day}: {package_versions}")

    validate_all_shas(all_shas, dev_versions_today, dev_versions_yesterday)
    return all_shas


def validate_all_shas(all_shas, dev_version_today, dev_version_yesterday):
    """
    Validate extracted SHA combinations.

    These error checks should not be considered exhaustive.

    Parameters
    ----------
    all_shas : dict[str, dict[str, str]]
        A dictionary where keys are the package and the values are a dict of
        days and short SHAs.
    dev_version_today : str | None
        SCM version string for today's package versions. Required for logging.
    dev_version_yesterday : str | None
        SCM version string for yesterday's package versions. Required for
        logging.

    Raises
    ------
    ValueError
        If SCM versions do not contain consistent SHAs. Errors can be
        propagated up to generate the HTML report without unreliable SHA data.
    """
    partial_message = (
        f"dev_version_today={dev_version_today} dev_version_yesterday="
        f"{dev_version_yesterday} pkg_shas={all_shas}"
    )
    packages = ["ESMValCore", "ESMValTool"]

    if not all(all_shas[package] for package in packages):
        raise ValueError("Missing SHAs: " + partial_message)
